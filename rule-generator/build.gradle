import java.util.concurrent.TimeUnit

buildscript {
    repositories {
        maven {
            url "${artifactory_contextUrl}/repo"
            credentials {
                username = "${artifactory_user}"
                password = "${artifactory_password}"
            }
        }

        dependencies {
            classpath 'com.resolutebi:GradleCommonConfigurationPlugin:1.0.+'
        }
    }
}

plugins {
    id 'application'
    id 'com.github.johnrengelman.shadow' version '1.2.3'
    id 'eclipse'
}

apply plugin: 'resolute-common-config'

test {
  exclude 'com/resolute/rule/generator/integration/*Test.class',
          '**/*DaoTest.class'
}

eclipse.project {
    natures 'org.springsource.ide.eclipse.gradle.core.nature'
}
mainClassName = 'com.resolute.rule.generator.RuleGeneratorApplication'

project.ext {
    dropwizardVersion = '1.3.5'
}

group 'com.resolute'

task wrapper(type: Wrapper) {
    gradleVersion = '2.14'
    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
}

sourceCompatibility = '1.8'
targetCompatibility = '1.8'

def thisDockerImage = 'rule-generator'

resoluteDocker {
  artifacts = [
    thisDockerImage
  ]
}

dependencies {
	compile "io.dropwizard:dropwizard-core:${dropwizardVersion}",
            "io.dropwizard:dropwizard-jdbi:${dropwizardVersion}",
            "io.dropwizard:dropwizard-migrations:${dropwizardVersion}",
            "io.dropwizard:dropwizard-testing:${dropwizardVersion}",
            "io.dropwizard:dropwizard-auth:${dropwizardVersion}",
            "io.dropwizard:dropwizard-assets:${dropwizardVersion}",
            "com.resolute:tag-query-expression-parser:${rbiDepVersion}",
            "com.resolute:node-traversal-expression-parser:${rbiDepVersion}",
            "com.resolute:app-service-common:${rbiDepVersion}",
            "com.resolute:tag-query-expression-parser:${rbiDepVersion}",
            "com.resolute:node-traversal-expression-parser:${rbiDepVersion}"
	
    testCompile 'junit:junit:4.12', 
                'org.mockito:mockito-core:1.10.19',
                'org.hamcrest:hamcrest-all:1.3',
                'io.takari.junit:takari-cpsuite:1.2.7',
                "com.resolute:app-service-common-test:3.5.48",
                "com.resolute:java-docker-db:${rbiDepVersion}"
}

shadowJar {
    mergeServiceFiles()
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'
    
    archiveName = "${rootProject.name}-all.${extension}"
}

jar {
    manifest {
        attributes 'Main-Class': mainClassName
    }
}

clean.doFirst {
    logger.quiet("docker rmi -f ${thisDockerImage}:previous || true")
    exec {
        // If your environment was clean it won't delete anything, hence the true to offset the error
        commandLine "/bin/bash", "-c", "docker rmi -f ${thisDockerImage}:previous || true"
    }
    logger.quiet("docker tag ${thisDockerImage} ${thisDockerImage}:previous")
    exec {
        commandLine "/bin/bash", "-c", "docker tag ${thisDockerImage} ${thisDockerImage}:previous || true"
    }
    logger.quiet("docker rmi -f ${thisDockerImage} || true")
    exec {
        // If your environment was clean it won't delete anything, hence the true to offset the error
        commandLine "/bin/bash", "-c", "docker rmi -f ${thisDockerImage} || true"
    }
}

shadowJar { 
	doLast {
	    def versionFile = project.file("${buildDir}/version.txt")
	    versionFile.text = """${rootProject.name} ${project.name} ${project.version}"""
	    logger.quiet("docker build -t ${thisDockerImage} -f ./docker/Dockerfile .")
	    exec {
	        commandLine "/bin/bash", "-c", "docker build -t ${thisDockerImage} -f ./docker/Dockerfile ."
	    }
	   logger.quiet("docker rmi -f \$(docker images ${thisDockerImage}:previous -q) || true")
        exec {
            // If your environment was clean it won't delete anything, hence the true to offset the error
            commandLine "/bin/bash", "-c", "docker rmi -f \$(docker images ${thisDockerImage}:previous -q) || true"
        }
	}
}

task runApp(dependsOn: shadowJar) {
	doLast {
        logger.quiet("docker rm -f ${thisDockerImage} || true")
        exec {
            // If your environment was clean it won't delete anything, hence the true to offset the error
            commandLine "/bin/bash", "-c", "docker rm -f ${thisDockerImage} || true"
        }	
	
	    logger.quiet("docker run -d --rm -p 8080:8080 -h localhost --env-file docker/local.env --name ${thisDockerImage} ${thisDockerImage}:latest")
		project.exec {
			commandLine "/bin/bash", "-c", "docker run -d --rm -p 8080:8080 -h localhost --env-file docker/local.env --name ${thisDockerImage} ${thisDockerImage}:latest"
		}
	}
}

task stopApp {
 	doLast {
    		exec {
    		    commandLine "/bin/bash", "-c", "docker stop ${thisDockerImage}"
    		}
	}
}
